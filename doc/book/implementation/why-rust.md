% Why Rust?

Seax is written using the [Rust](http://www.rust-lang.org) programming language. As far as programming languages go, Rust is very young &mdash; version 1.0 of Rust was released earlier this year. Since the language is so young, the astute reader would be likely to assume (not incorrectly) that Rust is likely to be very unstable.

Why, then, have I chosen to use such a young and unstable language for my implementation of Seax? What benefits does Rust provide that make up for the difficulties of working with a bleeding-edge language?

Developement of platforms on which other software is implemented, such as compilers, runtime environments, and libraries, is a pleasingly demanding task. While faults in application software have often had major economic consequences and sometimes can even place human lives in danger, the implementors of applications need only be responsible for the correctness of their own code, but also for ensuring that all the code executed on the platform is run correctly. Furthermore, as I have [discussed previously](/background/goals.html#performance), a software runtime environment has a major influence on the performance of all the programs that run on that platform. Therefore, ensuring that Seax is as fast and as error-free as possible are concerns of paramount importance, and should take precedence over concerns of developer convenience.

Typically, when one wishes to develop high-performance software, a low-level compiled langauge is employed. C is the prototype of such a language; and it (or occasionally its' mutant spawn C++) is the typical platform for the implementation of systems such as compilers and runtime environments. However, in order to benefit from C's blazing speed, the programmer must make a deal with the Devil; C's distinct lack of memory safety makes it also approximately the most error-prone programming language of all. As the old saw holds, "C makes it easy to shoot yourself in the foot". Recieved wisdom holds that one cannot have both speed and safety at the same time.

Rust offers both speed and safety at the same time. What is deeply innovative about Rust is its memory management system, based on the concept of _ownership_. Rather than using garbage collection to ensure memory safety, Rust enforces memory safety at compile time, with most data types allocated on the stack rather than the heap. That this reasoning is performed by the compiler rather than at runtime means that Rust applications can remain lightweight and close to the machine.

For some more of my initial experiences in Rust, interested readers may wish to read [this notebook entry](http://hawkweisman.me/notebook/rust,programming/2015/01/20/first-steps-in-rust/).